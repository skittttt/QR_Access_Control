Цель: реализовать устойчивое и воспроизводимое решение пропускного
режима по QR-коду, в котором валидация права входа выполняется локально,
но архитектура приложения остаётся приближенной к промышленным
стандартам (data layer, сетевой слой, асинхронность, внедрение
зависимостей).
Задачи в рамках курсовой работы:
1. Реализовать стартовый экран, на котором пользователь выбирает роль:
   «Администратор» или «Пользователь».
2. Сформировать пользовательский поток: список мероприятий → экран с
   детальной информацией → генерация и отображение личного QR-кода.
   QR-код должен содержать как минимум userId и eventId.
3. Сформировать администраторский поток: экран сканера QR (камера)
   → отображение сведений о пользователе и мероприятии → выбор
   «Пропустить» / «Отказать» с фиксацией решения. При успешном
   пропуске ведётся счётчик количества пропущенных гостей по
   текущему мероприятию.
4. Смоделировать сетевые вызовы через mock-API на базе Retrofit и
   OkHttp с искусственной задержкой ответа 200–500 мс; настроить DI
   (Dagger2) и реактивный обмен данными (RxJava). Это необходимо,
   чтобы отработать архитектурный паттерн «presentation → domain →
   data» без настоящего сервера.
5. Исключить обработку персональных данных: в QR не хранятся ФИО
   или контактные данные, только технические идентификаторы.
3. Описание алгоритмов и подзадач решения основной задачи
   Основная задача приложения — допустить (или не допустить) пользователя к
   конкретному мероприятию по его QR-коду.
   Эта задача разбивается на следующие ключевые алгоритмические подзадачи.
   3.1. Алгоритм формирования и отображения пропускного QR-кода
   (сторона пользователя)
   Входные данные: выбранное пользователем мероприятие (идентификатор
   события eventId), идентификатор пользователя userId. Дополнительно может
   включаться поле issuedAt (метка времени выдачи кода) для наглядности.
   Шаги выполнения:
1. Пользователь в приложении открывает список мероприятий и выбирает
   нужное событие. В карточке события он видит название, дату/время,
   локацию, описание и организатора.
2. На экране деталей мероприятия пользователь нажимает кнопку
   «Показать QR». Приложение формирует структуру данных вида:
   {
   "userId": "U12345",
   "eventId": "E20241001",
   "issuedAt": 1696166400
   }
   Набор полей может быть минимальным — userId, eventId — чтобы не
   хранить ФИО и не обрабатывать персональные данные.
3. Эта структура кодируется в QR-код локально, без обращения в сеть.
4. На экране отображается сгенерированный QR-код и подсказка вида
   «Покажите контролёру».
   Выходные данные: готовое к предъявлению администратору изображение
   QR-кода с полезной нагрузкой (payload), содержащей необходимые
   идентификаторы доступа.
   3.2. Алгоритм сканирования и принятия решения о допуске (сторона
   администратора)
   Входные данные: поток с камеры администратора, распознанная строка из
   QR-кода.
   Шаги выполнения:
1. Администратор выбирает свою роль на стартовом экране и попадает на
   экран сканера. Открывается предпросмотр камеры с рамкой наведения
   и (при необходимости) кнопкой включения фонарика. Приложение
   запрашивает разрешение CAMERA во время выполнения (runtime
   permission).
2. При успешном чтении QR-кода строка разбирается как JSON.
   Извлекаются как минимум userId и eventId.
3. Приложение обращается к локальному хранилищу (mock-слой
   данных), где есть:
   o список мероприятий с их параметрами (название, время
   проведения, локация);
   o учёт уже пропущенных пользователей для данного eventId.
   Эти данные предоставляются через интерфейсы Retrofit, но
   фактически отдаются из mock-реализации с искусственной
   задержкой 200–500 мс, чтобы эмулировать сетевую проверку.
4. Строится карточка результата для администратора:
   o идентификатор пользователя (и/или отображаемое имя, если
   предусмотрено в демонстрационных данных),
   o название и время мероприятия (по eventId),
   o статус допуска: «не проходил» / «уже проходил».
5. Администратор нажимает «Пропустить» или «Отказать». При выборе
   «Пропустить» система фиксирует факт входа данного userId на это
   eventId. При «Отказать» вход не засчитывается.
   Выходные данные: обновлённый статус допуска и визуальная фиксация
   решения (например, «Прошёл» или «Отказано»).
4. Описание системы хранения данных
   В данном приложении хранилище организовано так, чтобы снаружи оно
   выглядело как полноценный сетевой сервис (Retrofit-интерфейсы, задержки
   ответа, асинхронные вызовы через RxJava), но фактически данные хранятся
   локально в памяти приложения. Это позволяет отрабатывать архитектурный
   подход (слой данных → доменный слой → слой представления) даже без
   реального сервера. Такой же приём — разделение логики и состояния во
   внутреннем уровне и работа с ним через абстракцию репозитория —
   используется и в исходном образце, где UI не обращается к данным
   напрямую, а работает через ViewModel и Repository.
   4.1. Управление состоянием
   • Используется слоистая архитектура:
   o presentation: Activity / Fragment + ViewModel — отображение
   экранов, реакция на действия пользователя/администратора;
   o domain: use-case’ы (проверка допуска, генерация QR, получение
   списка мероприятий), а также доменные модели (пользователь,
   мероприятие, пропуск);
   o data: репозитории, mock-API и внутренние структуры данных в
   памяти (в том числе учёт пропущенных пользователей).
   • Вся работа с данными идёт через репозитории, которые
   предоставляются во ViewModel через внедрение зависимостей
   (Dagger2). ViewModel не знает, что данные на самом деле «фейковые»
   и приходят не из сети, а из локального списка. Это важно для
   соблюдения чистой архитектурной границы.
   • Асинхронность реализуется через RxJava (IO-поток имитирует сетевой
   вызов с задержкой; результат доставляется в основной поток UI). Такой
   подход моделирует поведение реального клиента, который ждёт ответа
   сервера.
   • Экран администратора дополнительно хранит временное состояние
   счётчика допущенных и список уже прошедших userId для текущего
   eventId, чтобы правильно показывать статус «не проходил / уже
   проходил». Это состояние живёт в репозитории и/или во ViewModel
   администратора и сбрасывается при перезапуске приложения (что
   допустимо в рамках учебной модели).
   4.2. Структуры данных
   В рамках приложения используются следующие основные структуры:
   • Event
   o eventId: String
   o title: String
   o dateTime: String
   o location: String
   o description: String
   Эти данные отображаются в пользовательском списке
   мероприятий и на экране деталей мероприятия.
   • AccessTicket (полезная нагрузка QR)
   o userId: String
   o eventId: String
   o issuedAt: Long (опционально для демонстрации времени выдачи)
   Этот объект сериализуется в JSON и кодируется в QR-код.
   • AccessDecision
   o статус допуска для конкретного (userId, eventId) — «не
   проходил» или «уже проходил»;
   o результат нажатия «Пропустить» / «Отказать»;
   o текущее значение счётчика «пропущено».
   Эти структуры не покидают устройство и не передаются во внешние
   сервисы. Персональные данные пользователя (ФИО, контакты) не требуются
   и не записываются в QR или логику допуска, что снижает риски обработки
   персональных данных.